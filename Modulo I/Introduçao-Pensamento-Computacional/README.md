# Introdu√ß√£o a Programa√ß√£o e Pensamento Computacional

###### Iniciado: May 26, 2022 11:46 AM
###### Completo: Yes
###### Teacher: [Juliana Mascarenhas](https://github.com/julianazanelatto)
###### [Link da Aula](https://web.dio.me/course/introducao-a-programacao-e-pensamento-computacional/learning/285a4323-c6b0-4233-988e-4a2954065de3?back=/track/tqi-fullstack-developer&tab=undefined&moduleId=undefined)
###### [Slide da Aula](https://drive.google.com/file/d/1vemC6G790JNte1882V53DAKEawJzVIWL/view)

##

Pensamento computacional ou l√≥gica de programa√ß√£o √© algo aplic√°vel a qualquer √°rea de conhecimento, n√£o s√≥ para programa√ß√£o e TI, mas pra qualquer local onde resolu√ß√£o de problemas √© uma skill importante.

<details>
    <summary>Summary</summary>
    
     - Pensamento Coomputacional
     - Introdu√ß√£o a l√≥gica de programa√ß√£o
     - Fundamentos de Algoritmos
     - Linguagens de Programa√ß√£o
     - Primeiro contato com a Programa√ß√£o
    
</details>

# Pensamento Computacional

// Os primeiros passos para come√ßar a programar

## Introdu√ß√£o

**Defini√ß√£o:** O processo de pensamento envolvido na express√£o de solu√ß√µes em passos computacionais ou algoritmos que podem ser implementados no computador.

Olha, o pensamento computacional n√£o se limita ao computador, o que significa que o pensamento computacional √© o pensar no passo a passo que vai levar a solu√ß√£o para o problema em quest√£o. Pensando assim, percebe-se que o pensamento computacional √© mais uma skill do que um assunto acad√™mico de um curso espec√≠fico, e est√° presente n√£o s√≥ dentro do mundo tecnol√≥gico, mas tamb√©m na matem√°tica, na leitura, na escrita, no planejamento, etc.

Seus pilares em que se divide s√£o: Decomposi√ß√£o, reconhecimento de padr√µes, abstra√ß√£o e design de algoritmos. N√£o que pra todo problema seja necess√°rio a uni√£o da for√ßa dos 4 pilares pra resolv√™-lo, mas normalmente sim.

Dentre as compet√™ncias adquiridas na utiliza√ß√£o do pensamento computacional podem ser percebidos o pensamento sistem√°tico, a colabora√ß√£o dentro da equipe, a criatividade e design, e tudo isso acaba facilitando a resolu√ß√£o do problema.

## Habilidades complementares

As habilidades mais necess√°rias ao pensamento computacional √© o racioc√≠nio l√≥gico e o aperfei√ßoamento, super atreladas a resolu√ß√£o de problemas.

Racioc√≠nio l√≥gico √© uma forma de pensar estruturadamente de forma que se chegue a uma conclus√£o, e pode ser classificado em indu√ß√£o, dedu√ß√£o e abdu√ß√£o. Indu√ß√£o √© voc√™ generalizar uma teoria a partir de um fen√¥meno espec√≠fico, a dedu√ß√£o, sendo o oposto, √© voc√™ especificar um fen√¥meno a partir de uma teoria geral. A abdu√ß√£o √© um pouco diferente, pois a indu√ß√£o e a dedu√ß√£o tratam de ideias e teorias com fen√¥menos e casos, mas a abdu√ß√£o √© voc√™ definir uma suposi√ß√£o a partir de um fato, elaborar uma premissa a partir de uma conclus√£o. Ent√£o, numa infer√™ncia, a abdu√ß√£o e a indu√ß√£o se encaixam numa s√≠ntese, e a dedu√ß√£o se encaixa na an√°lise.

Aperfei√ßoamento tamb√©m pode ser chamado de refinamento, melhoramento, aprimoramento ou ato de aperfei√ßoar, basicamente √© voc√™ determinar pontos de melhora e refinamento quando j√° se tem uma solu√ß√£o, mas uma solu√ß√£o que pode ser mais eficiente ao seu objetivo, de forma local ou global. Nisso, pode ser poss√≠vel fazer um uso melhor dos recursos, como encontrar uma outra solu√ß√£o mais eficiente ou otimizar processos da atual, ou ent√£o melhorar os c√≥digos e algoritmos, simplificando as linhas ou verificando que as fun√ß√µes est√£o bem definidas. Todos s√£o op√ß√µes.

## Pilares

### Decomposi√ß√£o

> ‚ÄúIf you can‚Äôt solve a problem, then there is an easier problem that you can solve: find it‚Äù. George Polya.
> 

I.e. um problema complexo e grande pode ser quebrado em problemas mais simples e menores, mais f√°ceis de serem resolvidos. Como fazer isso? Podemos usar a estrat√©gia de an√°lise, que √© estudar e explorar o nosso problema a fim de encontrar os conjuntos independentes e complementares que formam o todo. E ent√£o fazermos a estrat√©gia da s√≠ntese, que √© construir, no caso aqui √© reconstruir as partes, os elementos de cada parte que foi separado, fundindo-os de volta de maneira coerente, alcan√ßando a solu√ß√£o pro problema total. Podemos fazer isso de maneira sequencial ou paralela.

Mas isso foi s√≥ teoria aqui, pra saber mesmo o que √© decomposi√ß√£o s√≥ decompondo. Um passo a passo simplificado(?) seria: 

- Identifica ou coleta os dados;
- Agrega os dados;
- Encontra a solu√ß√£o e entrega a funcionalidade.

Basicamente: segmentar, interligar, recompor.

### Padr√µes

Podemos pensar em padr√µes como um modelo, algo que pode ser repetido conforme um molde base, recriando infinitas vezes uma estrutura invari√°vel. Ent√£o, para conseguir um bom reconhecimento de padr√µes, encontrar padr√µes, precisamos prestar aten√ß√£o em similaridades e diferen√ßas, e √© claro que estamos falando de grupos, m√∫ltiplos, muitos ou, ao menos, pelo menos 3 elementos, pois n√£o h√° padr√£o onde n√£o h√° um comparativo.

N√≥s naturalmente fazemos esse processo de reconhecimento de padr√µes, mas a m√°quina n√£o. Por isso que para o pensamento computacional voltado a programa√ß√£o √© importante que saibamos reconhecer, descrever e determinar os padr√µes para poder ensinar a m√°quina a fazer o mesmo. Realizamos isso fazendo uso de classes e categorias, atrav√©s do grau de similaridade e ent√£o classificando em categorias conhecidas ou de um objeto desconhecido. Mas para a m√°quina poder fazer isso tamb√©m, ela ir√° usar de compara√ß√£o. O que pode dificultar a√≠ √© a falta de dados suficientes, pois o computador √© objetivo, direto, simples e burro, ele n√£o tem os dados por si s√≥, o programador tem que entregar pra ele primeiro.

A partir da√≠, ap√≥s o computador ter uma boa representa√ß√£o dos atributos e os conceitos associados a cada objeto, armazenamos os dados e podemos definir as regras de decis√£o.

Ent√£o, resumindo, a abordagem para detec√ß√£o de padr√£o envolve a extra√ß√£o de caracter√≠sticas e a classifica√ß√£o de dados, o que pode usar de diferentes m√©todos para aplicar em diferentes contextos. Dentre as √°reas dentro da Tecnologia que utilizam bastante o reconhecimento de padr√µes est√£o machine learning, redes neurais, intelig√™ncia artifical e ci√™ncia de dados, de uma forma ou outra.

### Abstra√ß√£o

Sabemos que abstrair √© avaliar caracter√≠sticas e propriedades a partir da observa√ß√£o de um ou mais elementos, j√° a abstra√ß√£o √© o processo intelectual de isolamento de uma objeto da realidade, e generalizar √© tornar algo geral, extenso. Abstra√ß√£o/Generaliza√ß√£o como pilar do pensamento computacional ser√° a soma dessas tr√™s coisas.

Simplificando, √© definir classes gerais pra envolver objetos com base em suas caracter√≠sticas e pontos essenciais. Classificar, observando os dados importantes e desconsiderando detalhes f√∫teis.

Conceitos existentes baseados em abstra√ß√£o.. lembra de estruturas? Ent√£o‚Ä¶ todos eles eram TAD, n√©? Tipos abstratos de dados..

### Algoritmos

O computador √© uma √≥tima ferramenta, no sentido de que √© eficiente, r√°pido e trabalha muito sem gastar muita energia, mas apesar dos seus pros, ele n√£o opera sozin. Ele n√£o resolve problema se ele n√£o receber instru√ß√µes detalhadas, de uma forma bem simplificada, para que ele entenda o que fazer e como. No fim, o objetivo de um computador √© receber, manipular e armazenar dados.

Os programas s√£o constitu√≠dos de instru√ß√µes, que o computador vai replicar, mas essas instru√ß√µes precisam conter o que precisa ser feito e a ordem de execu√ß√£o, um passo a passo, de forma a ser entendido pelo homem e pela m√°quina. O algoritmo √© esse passo a passo.

Pra desenvolver um programa, √© preciso analisar, entender e definir os dados de entrada e sa√≠da, formular o algoritmo usando ferramentas narrativas (utilizando a l√≠ngua nativa, mas pode ficar amb√≠guo), de fluxograma (estrutura gr√°fica simples, mas requer conhecimento dos s√≠mbolos) ou de pseudoc√≥digo (portugol, esse voc√™ j√° conhece), e ent√£o codificar, traduzir os passos para c√≥digo na linguagem de prefer√™ncia.

Mas como construir um algoritmo?

1. Compreenda o problema, os pontos mais importantes;
2. Defina os dados de entrada, os dados fornecidos pelo contexto;
3. Defina o processamento, c√°lculos e restri√ß√µes;
4. Defina os dados de sa√≠da, ap√≥s o processamento;
5. Utilize um m√©todo de constru√ß√£o e refinamento;
6. Realize testes e diagn√≥sticos.

## Estudos de caso

### Conceitual: Perdido

Voc√™ est√° perdido numa floresta.Voc√™ olha ao redor e se pergunta:‚ÄùComo que eu consigo utilizar o pensamento computacional para maximizar minhas changes de sobreviv√™ncia?‚Äù.

Primeiro podemos identificar mecanismos, recursos comuns e os detalhes mais importantes, ou seja, preciso de abrigo, comida e √°gua. Para o abrigo eu preciso de uma boa localiza√ß√£o que seja quente e seco e me garanta prote√ß√£o. Para a comida eu posso ca√ßar e/ou coletar. Para a √°gua eu posso procurar uma nascente ou coletar da chuva.

Para purificar a √°gua, cozinhar a ca√ßa, garantir a prote√ß√£o e o calor √© necess√°rio que eu tenha fogo, ent√£o fogo √© um padr√£o, e para entender a localiza√ß√£o eu preciso de um mapa, que pode ser criado atrav√©s da abstra√ß√£o. At√© ent√£o j√° fizemos decomposi√ß√£o, reconhecimento de padr√µes e abstra√ß√£o, agora s√≥ preciso comer. Para isso eu preciso preparar a comida, seguindo as etapas:

#### 1¬∞ op√ß√£o
1. Pescar
2. Limpar o peixe
3. Assar o fil√©
4. Comer

#### 2¬∞ op√ß√£o

1. Pescar
2. Limpar o peixe
3. Colocar √°gua na panela 
4. Ferver a √°gua
5. Fazer o cozido
6. Comer

E o mesmo processo de pensamento vai para encontrar a √°gua, construir o abrigo, etc.

### Aplicado: Soma de um intervalo

Se tivermos uma sequencia de n√∫meros, digamos, inteiros entre 1 e 100, e quisermos saber a soma, podemos encontr√°-la de uma forma inteligente e eficiente.

1 + 100 = 101

2 + 99 = 101

3 + 98 = 101

4 + 97 = 101

Podemos perceber um padr√£o nessa decomposi√ß√£o espec√≠fica, o n√∫mero 101 se repete 100/2 vezes, o que facilita nossa conta: 101 * 50 = 5050

Podemos fazer uma generaliza√ß√£o.

Soma de n¬∞ entre x e y, o intervalo √© [x, y] e o resultado_repetido_padrao = x + y e o resultado vai ser y/2 * (y + x).

Ent√£o utilizando decomposi√ß√£o, reconhecimento de padr√µes e abstra√ß√£o, podemos desenvolver o algoritmo:

1. Recebe os valores (x e y)
2. Resolve y/2 = total
3. Resolve y+x = resultado_repetido_padrao
4. Acha o resultado final = total * resultado_repetido_padrao
5. Imprime final

### Aplicado: Adivinhe o n√∫mero

Dado que existe um n√∫mero misterioso que uma pessoa escolheu dentro de um intervalo, eu fa√ßo perguntas e as √∫nicas respostas poss√≠veis √© sim ou n√£o. Nesse jogo, chutar n√∫meros aleatoriamente √© ineficiente e perde muito tempo, mas se as perguntas forem do tipo ‚Äún√∫mero √© maior que x?‚Äù ou ‚Äún√∫mero √© menor que y?‚Äù √© uma estrat√©gia bem melhor.

Esse cen√°rio nos lembra uma busca bin√°ria em um vetor. E nesse sentido um poss√≠vel algoritmo seria:

1. ordenar o vetor
2. fazer o m√≥dulo de L/2
3. acessar a estrutura
4. comparar os valores
5. repetir at√© encontrar o n√∫mero
6. imprimir ‚ÄúBusca bem sucedida‚Äù

<aside>
üìé Como aprimorar essa habilidade? Desafiando-se a explicar as decis√µes e o processo com palavras simples.

</aside>

# Introdu√ß√£o √† L√≥gica da Programa√ß√£o

O conceito de l√≥gica aplicada a programa√ß√£o.

## O que √© l√≥gica?

**Defini√ß√£o:** Parte da filosofia que trata das formas do pensamento em geral (dedu√ß√£o, indu√ß√£o, hip√≥tese, infer√™ncia, etc.) e das opera√ß√µes intelectuais que visam √† determina√ß√£o do que √© verdadeiro ou n√£o.

Ent√£o √© uma forma de pensar estruturadamente, um racioc√≠nio coeso e com sentido. Passando isso para o universo da programa√ß√£o, entendemos que a l√≥gica nos c√≥digos garante a organiza√ß√£o e planejamento das instru√ß√µes, em um algoritmo, a fim de viabilizar o nosso programa.

> ‚ÄúEverybody in this country should learn how to program a computer because it teaches you how to think.‚Äù Steve Jobs.
> 

## T√©cnicas de l√≥gica de programa√ß√£o

A primeira t√©cnica dispon√≠vel √© a **t√©cnica linear:**

- √â um modelo tradicional;
- N√£o tem v√≠nculo;
    - Estrutura hier√°rquica;
    - Programa√ß√£o de computadores;
- Execu√ß√£o sequenciada;
- Recursos limitados;
- √önica dimen√ß√£o;

√â a ordena√ß√£o de elementos por uma √∫nica propriedade.

A segunda t√©cnica √© a **t√©cnica estruturada**, que se denota na organiza√ß√£o, disposi√ß√£o e ordem dos elementos essenciais que comp√µem um corpo, ou seja, tem-se uma estrutura disposta de tal forma que segue uma ordem l√≥gica. Para programas, usar esse tipo de t√©cnica facilita a escrita, o entendimento, a valida√ß√£o e a manuten√ß√£o.

A terceira t√©cnica √© a **t√©cnica modular**, que trata de partes independentes (os m√≥dulos) que s√£o controlados por um conjunto de regras, mas cada um tem o seu pr√≥prio e espec√≠fico. O modelo padr√£o para essa t√©cnica √©:

Dados de entrada ‚Üí Processo de transforma√ß√£o ‚Üí Dados de sa√≠da

Com essa t√©cnica n√≥s conseguimos:

- Simplifica√ß√£o
- Decompor o problema
- Verifica√ß√£o por m√≥dulo

# Fundamentos de Algoritmos

## Tipologia e vari√°veis

O computador processa as informa√ß√µes que damos pra ele, definindo dados e instru√ß√µes. Os dados s√£o tratados e processados pelo computador, e podem se encaixar em um dentre v√°rios tipos de dados existentes: num√©ricos, caracteres, l√≥gicos‚Ä¶ Os num√©ricos podem ser inteiros ou reais, os caracteres s√£o todos os s√≠mbolos, at√© mesmo os dos n√∫meros, dentro de aspas, e o l√≥gico est√° atrelado a l√≥gica booleana, sendo ou verdadeiro ou falso.

Uma v√°riavel √© um tipo de estrutura que possui varia√ß√µes. Duh. Ela pode assumir qualquer valor de qualquer tipo de dado, mas uma vez que seu tipo for definido, ela est√° restrita a esse tipo. Para nomear vari√°veis existem algumas regrinhas, mas s√£o mais boas pr√°ticas do que regras, porque cada linguagem pode ter suas peculiaridades quanto a declara√ß√£o de vari√°veis. S√£o estas:

- Atribui√ß√£o de um ou mais caracteres
- A primeira letra n√£o pode ser n√∫mero
- Sem espa√ßos em branco
- Sem usar palavras reservadas
- Caracteres e n√∫meros s√£o v√°lidos

Var√≠aveis podem ser criadas com duas fun√ß√µes principais, de a√ß√£o ou de controle, aquela sendo para modificar o algoritmo e essa pra vigiar o algoritmo. Algumas vezes precisamos de vari√°veis que sejam fixas e invari√°veis, no caso, uma constante, e podemos sim criar vari√°veis com o prop√≥sito de n√£o variarem. Algumas linguagens tem uma declara√ß√£o espec√≠fica para essa vari√°vel constante.

## Instru√ß√µes primitivas

As instru√ß√µes s√£o comandos que iram tratar os dados, no caso de dados do tipo num√©rico, temos operadores aritm√©ticos, como adi√ß√£o, subtra√ß√£o, divis√£o, etc. 

Cada linguagem ter√° um vocabul√°rio espec√≠fico pr√≥prio para realizar um comando, e outra linguagem pode realizar esse mesmo comando, mas representando-o com outra nota√ß√£o. Ent√£o o mesmo comando pode ser representado por nota√ß√µes distintas, com base na sintaxe particular de cada linguagem.

√â importante tamb√©m entender a entrada, processamento e sa√≠da dos dados em um algoritmo. 

## Estruturas condicionais e operadores

Se quisermos utilizar se alguma verifica√ß√£o no algoritmo temos as estruturas condicionais, o nome √© porque dado uma condi√ß√£o uma opera√ß√£o √© executada, se a condi√ß√£o for satisfeita, ou n√£o, se n√£o for. Essas estruturas podem ser simples, compostas ou encadeadas. A simples somente verifica a condi√ß√£o, a composta define uma exce√ß√£o, e a encadeada trata de uma condicional dentro de uma condicional.

Para tratar as condi√ß√µes, utilizamos operadores relacionais, como o igual a, diferente de, maior que, menor que, maior ou igual a, menor ou igual a. Seus s√≠mbolos s√£o normalmente os mesmos, mas dependendo da linguagem eles podem variar. Agora os operadores l√≥gicos tendem a n√£o mudar muito, s√£o eles o and, or e not, e tamb√©m servem para constituir as condi√ß√µes, quando precisamos de respostas simplificadas de sim ou n√£o.

## Estruturas de repeti√ß√£o

Quando √© necess√°rio que um mesmo grupo de comandos sejam executados repetidamente, podemos usar uma estrutura de repeti√ß√£o pra poder escrever esses comando uma vez s√≥, poupando linhas, tempo, compreens√£o e manuten√ß√£o, al√©m de evitar erros. La√ßos, controle de fluxo, malhas de repeti√ß√£o, loop s√£o todos sin√¥nimos de repeti√ß√£o. 

Quando constru√≠mos essa estrutura, definimos tamb√©m uma condi√ß√£o de parada, sendo um n√∫mero de repeti√ß√µes pr√©-fixada ou uma condi√ß√£o a ser satisfeita, para que o loop pare de repetir-se e o cursor saia do la√ßo, evitando assim o loop infinito.

Pensando em tipos, existem 3:

- Enquanto ‚Ä¶ fa√ßa
    
    Condi√ß√£o no in√≠cio. N√∫mero de repeti√ß√µes indefinida.
    
- Repita ‚Ä¶ at√©
    
    Condi√ß√£o no final. N√∫mero de repeti√ß√µes indefinida.
    
- Para ‚Ä¶ de ‚Ä¶ at√© ‚Ä¶ fa√ßa
    
    Condi√ß√£o no in√≠cio. N√∫mero de repeti√ß√µes definida.
    

## Vetores e matrizes

Um vetor √© uma vari√°vel que representa uma sequencia unidimencional de dados com tamanho pr√©-fixado.

Uma matriz √© uma tabela organizada em linhas e colunas, de dimens√£o m x n. Quase como se fosse um grupo de vetores de mesmo tamanho, um em baixo do outro, e cada um identificado por um √≠ndice.

Essas estruturas mais complexas servem para facilitar nosso entendimento do c√≥digo, a otimiza√ß√£o, manuten√ß√£o e a escrita do c√≥digo, quando estamos lidando com muitos dados.

## O que s√£o fun√ß√µes?

As fun√ß√µes em programa√ß√£o s√£o similares ao conceito de fun√ß√£o em matem√°tica; s√£o blocos de instru√ß√µes que realizam tarefas espec√≠ficas. A modulariza√ß√£o do programa. Identificados por nomes e par√¢metros.

As vari√°veis criadas dentro de uma fun√ß√£o pertencem ao escopo local da fun√ß√£o, dendo desalocadas da mem√≥ria uma vez que a fun√ß√£o encerra.

## Instru√ß√µes de entrada/sa√≠da

A entrada consiste na inser√ß√£o e recebimento de dados do mundo real por meio de a√ß√£o de alguma interface, seja teclado, mouse, arquivos, entre outros. E ent√£o, ap√≥s o processamento desses dados no algoritmo, a sa√≠da consiste na impress√£o dos dados do mundo abstrato, digital por meio de a√ß√£o de alguma interface.

Para toda sa√≠da, ela ocorre de forma bem sucedida, ou por erro no c√≥digo, ou por problema com a interface.

# Linguagens de Programa√ß√£o

## Introdu√ß√£o √† linguagens de programa√ß√£o

Hist√≥ria da computa√ß√£o. 2¬∞ Guerra Mundial e Guerra Fria. Ada Lovelace, Alan Turing, Von Neuman, Claude Shannon. ENIAC, EDVAC, COLOSSUS, Intel, Microsoft, Windows, Apple, IBM.

Assembly, a ‚Äúprimeira linguagem de programa√ß√£o‚Äù, era uma linguagem de montage, de m√°quina. COBOL, lisp, prolog, C, Java, C#, JS, python, Ruby, ‚Ä¶

Os problemas computacionais s√£o recorrentes. A necessidade de uma era gera espa√ßo para inova√ß√£o, e o que era inova√ß√£o, depois de sua era, n√£o √© mais, e novas necessidades s√£o a regra.

Uma linguagem de programa√ß√£o vai ser um m√©todo, um conjunto de regras que ao serem combinadas e movidas, podem alcan√ßar um resultado esperado e, quem sabe, nunca visto antes.

## Como um computador entende o programa?

O c√≥digo fonte √© traduzido ou interpretado pelo computador para o computador, pois o computador n√£o fala ingl√™s, portugu√™s, mandarim, etc.., o computador n√£o fala linguagens humanas. Mas codamos com palavras humanas, ent√£o, pra que o computador entenda os dados e instru√ß√µes do programa √© necess√°rio que o programa fonte passe por uma compilador gerando um programa objeto que est√° na linguagem de m√°quina. Esse processo se chama de compila√ß√£o ou tradu√ß√£o.

J√° a interpreta√ß√£o, o programa fonte √© executado diretamente, o que pode ter suas vantagens e desvantagens em compara√ß√£o com a compila√ß√£o. Python √© uma linguagem interpretada e C √© uma linguagem compilada.

Mais recente, surgiu a t√©cnica da transpila√ß√£o, que seria o programa fonte ser escrito em uma linguagem de alt√≠ssimo n√≠vel e ent√£o ser transpilada para uma linguagem de n√≠vel um pouco mais baixo, mas ainda n√£o de baixo n√≠vel, o que √© muito interessante pois garante a flexibilidade do c√≥digo de alto n√≠vel mas com uma execu√ß√£o um pouco mais r√°pida. Typescript √© transpilado com JavaScript.

## Caracter√≠sticas de um programa

Na hora de pensar em desenvolver um programa, √© bom pensar nos pontos:

- Legibilidade - ser leg√≠vel;
    
    Facilidade de leitura, compreens√£o, ortogonalidade, defini√ß√£o adequada das estruturas.
    
- Redigibilidade - ser de facil escrita;
    
    Ortogonalidade, simplicidade da escrita, coer√™ncia nas instru√ß√µes, suporte √† abstra√ß√£o, reuso do c√≥digo, expressividade.
    
- Confiabilidade - faz o que foi programado pra fazer;
    
    Verifique os tipos, trata das exce√ß√µes, usa bem o recurso dos ponteiros, compatibilidade entre compiladores.
    
- Custo - an√°√ßise de impacto;
    
    Treinamento, codifica√ß√£o, compila√ß√£o, execu√ß√£o, infra-estrutura.
    
- Atualiza√ß√µes;
- Iso para IA;
- Disponibilidade de ferramentas;
- Comunidade ativa;
- Ado√ß√£o pelo mercado.

## An√°lises de c√≥digo

Durante a leitura de um c√≥digo, algumas an√°lises acontecem l√° dentro.

- An√°lise l√©xica
    
    Ela √© a primeira fase. L√™ caractere por caractere e agrupa os caracteres por s√≠mbolos l√©xicos. Ela particiona o c√≥digo, classifica os elementos (tokens) e eliminar as maquiagens (espa√ßos em branco, coment√°rios).
    
- An√°lise sint√°tica
    
    A sintaxe √© a forma, e a an√°lise sint√°tica √© a corretude do programa. Extremamente dependente da linguagem espec√≠fica utilizada.
    
- An√°lise sem√¢ntica
    
    Est√° ligada ao estudo do significado e da l√≥gica do programa; um erro de sem√¢ntica seria quando o c√≥digo n√£o faz o que √© esperado, mas eles s√£o mais dificeis de se encontrar.
    

## Paradigmas de programa√ß√£o

Paradigma seria um exemplo de um padr√£o, um modelo complexo, uma estrutura, conceito ou procedimento que serve para instruir os movimentos e facilitar a resolu√ß√£o de um problema espec√≠fico. Em programa√ß√£o podem ser classificados como paradigmas:

- Orienta√ß√£o √† objeto;
- Procedural;
- Funcional;
- Estruturado;
- Computa√ß√£o distribu√≠da;
- L√≥gico;

Os mais utilizados nas linguagens s√£o a orienta√ß√£o √† objetos e o estruturado.

# Primeiro contato com a Programa√ß√£o

## Algoritmos em pseudoc√≥digo

    programa {

        funcao inicio() {
            inteiro x, y
    
            escreva(‚ÄùDigite os n√∫meros para executar a soma do intervalo: ‚Äú)

            leia(x)

            leia(y)

            escreva(soma_intervalo(x,y))
        }

        funcao inteiro soma_intervalo(inteiro x, inteiro y) {

            inteiro total, resultado_parcial

            total = y/2

            resultado_parcial = y+x

            inteiro resultado = total * resultado_parcial

            retorne resultado

        }

    }

;;;;

    programa {

        funcao inicio() {

            real a1, a2, b1, b2

            escreva (‚ÄùDigite a nota p1 e p2 do aluno A: ‚Äú)

            leia(a1)

            leia(a2)

            escreva(‚ÄùDigite as notas da p1 e p2 do aluno B: ‚Äú)

            leia(b1)

            leia(b2)

            escreva(‚ÄôM√©dia do aluno A: ‚Äú, media_aluno(a1, a2))

            escreva(‚Äù\nM√©dia do aluno B: ‚Äú, media_aluno(b1, b2))

        }

        funcao real media_aluno(real nota_a, real nota_b) {

            retorne (nota_a + nota_b)/2

        }

    }
